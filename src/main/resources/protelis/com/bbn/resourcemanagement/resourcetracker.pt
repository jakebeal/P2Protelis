module com:bbn:resourcemanagement:resourcetracker

import protelis:coord:accumulation
import protelis:coord:spreading
import protelis:coord:meta
import protelis:lang:utils
import protelis:coord:nonselfstabilizing:accumulation

// Deprecated --> will be replaced in a future Protelis release
def once(v) {
    rep(x <- v) { x };
}

def hopDistanceTo(leader) {
    rep(d <- Infinity) { mux(leader) { 0 } else { 1 + minHood(nbr(d)) } }
}

public def countDevices(potential) {
    C(potential, sum, 1, 0)
}

// TODO: check if I can just do this as Tuple.union
public def union(a, b) {
    a.union(b);
}

public def regionSet(potential) {
	C(potential, union, unionHood(nbr([self.getRegionName()])), []);
}

def countNodes() {
    let nonce = once(self.nextRandomDouble());
    let leader = nonce == gossip(nonce, min);
    //self.putEnvironmentVariable("blue",leader);
    let d = hopDistanceTo(leader);
    [leader, countDevices(d)];
}

def nbrRegions() {
    let nonce = once(self.nextRandomDouble());
    let leader = nonce == gossip(nonce, min);
    //self.putEnvironmentVariable("blue",leader);
    let d = hopDistanceTo(leader);
    [leader, countDevices(d), regionSet(d)];
}

nbrRegions();

let rgn = self.getRegionName();
//multiRegion(rgn,(n) -> { rgn == n },nbrRegions,[]);
//multiRegion(rgn,(n) -> { rgn == n },() -> { rgn },[]);
//multiRegion(2,(n) -> { 2 == n },() -> { 2 },NaN);
